#!/usr/bin/ruby

# Get the base directory of the WFM installation
if File.symlink?(__FILE__)
  __WFMDIR__=File.dirname(File.dirname(File.expand_path(File.readlink(__FILE__),File.dirname(__FILE__))))
else
  __WFMDIR__=File.dirname(File.expand_path(File.dirname(__FILE__)))
end

# Add include paths for WFM and libxml-ruby libraries
$:.unshift("#{__WFMDIR__}/lib")
$:.unshift("#{__WFMDIR__}/lib/libxml-ruby")
$:.unshift("#{__WFMDIR__}/lib/sqlite3-ruby")
$:.unshift("#{__WFMDIR__}/lib/SystemTimer")

require 'libxml-ruby/libxml'


##########################################
#
# simple_substitutions
#
##########################################
def simple_substitutions(string)

  string.gsub!(/<task\s+id=/,"<task name=")
  string.gsub!(/<var\s+id=/,"<var name=")
  string.gsub!(/<cycle_Y(\s+offset="\S+")?\/>/, '<cyclestr\1>@Y</cyclestr>')
  string.gsub!(/<cycle_y(\s+offset="\S+")?\/>/, '<cyclestr\1>@y</cyclestr>')
  string.gsub!(/<cycle_m(\s+offset="\S+")?\/>/, '<cyclestr\1>@m</cyclestr>')
  string.gsub!(/<cycle_d(\s+offset="\S+")?\/>/, '<cyclestr\1>@d</cyclestr>')
  string.gsub!(/<cycle_j(\s+offset="\S+")?\/>/, '<cyclestr\1>@j</cyclestr>')
  string.gsub!(/<cycle_H(\s+offset="\S+")?\/>/, '<cyclestr\1>@H</cyclestr>')
  string.gsub!(/<cycle_M(\s+offset="\S+")?\/>/, '<cyclestr\1>@M</cyclestr>')
  string.gsub!(/<cycle_S(\s+offset="\S+")?\/>/, '<cyclestr\1>@S</cyclestr>')

  string

end

##########################################
#
# set_sched
#
##########################################
def set_sched(node)

  node["scheduler"]=node.find_first("//task")["scheduler"]

end


##########################################
#
# set_cyclethrottle
#
##########################################
def set_cyclethrottle(node)

  node["cyclethrottle"]=node.find("//task").collect { |n| n["tries"] }.min

end



##########################################
#
# traverse
#
##########################################
def traverse(node)

#puts node.inspect
  return if node.entity?
  return if node.entity_ref?
  case node.name
    when "cycle"
      node.name="cycledef"
      node.attributes.each do |a|
        case a.name
          when "id"
            node["group"]=a.value
            a.remove!
          else
        end
      end
    when "task"
      node.attributes.each do |a|
        case a.name
          when "action"
            if node.to_s=~/action="([^"]+)"/
              action=$1
            end
            node.each_element do |e|                
              e.prev=LibXML::XML::Node.new("command",action)
              break
            end
            a.remove!
          when "tries"
            node["maxtries"]=a.value
            a.remove!
          when "throttle","scheduler"
            a.remove!
          when "cycle"
            node["cycledefs"]=a.value
            a.remove!
          else
        end
      end
    when "environment"
      node.name="envar"
    when "filedep"
      node.name="datadep"
    when "cyclestr"
      node.content=node.content.gsub("%","@")
    when "property"
      name_node=node.find_first("name")
      name_content=name_node.content
      value_node=node.find_first("value")
      value_content=value_node.content unless value_node.nil?
      case name_content
        when '-N'
          newnode=LibXML::XML::Node.new("jobname")
          value_node.each { |c| newnode << c.copy("deep") }
          node.next=newnode
          node.remove!
        when '-A'
          newnode=LibXML::XML::Node.new("account")
          value_node.each { |c| newnode << c.copy("deep") }
          node.next=newnode
          node.remove!
        when '-V','-cwd'
          node.remove!
        when '-pe'
          newnode=LibXML::XML::Node.new("cores")
          newnode << value_node.last.copy("deep")
          newnode.content=newnode.content.strip
          newnode.output_escaping=false
          node.next=newnode
          newnode=LibXML::XML::Node.new("queue")
          newnode << value_node.first.copy("deep")
          newnode.output_escaping=false
          node.next=newnode
          node.remove!
        when '-o'
          join=node.parent.find('./property[name="-j"]')
          if join.empty?
            newnode=LibXML::XML::Node.new("stdout")
          else
            newnode=LibXML::XML::Node.new("join")
          end
          value_node.each { |c| newnode << c.copy("deep") }
          node.next=newnode
          node.remove!
        when '-e'
          join=node.parent.find('./property[name="-j"]')
          if join.empty?
            newnode=LibXML::XML::Node.new("stderr")
          else
            newnode=LibXML::XML::Node.new("join")
          end
          value_node.each { |c| newnode << c.copy("deep") }
          node.next=newnode
          node.remove!
        when '-l'
          options=value_content.split(",")
          options.each do |opt|
            optname,optval=opt.split("=")
            case optname
              when "procs"
                newnode=LibXML::XML::Node.new("cores",optval)
              when "walltime","h_rt"
                newnode=LibXML::XML::Node.new("walltime",optval)
              when "vmem","h_vmem","mem"
                newnode=LibXML::XML::Node.new("memory",optval)
              else
                newnode=LibXML::XML::Node.new("native","-l #{opt}")
            end
            newnode.output_escaping=false
            node.next=newnode                                
          end
          node.remove!
        else
      end
    else
  end

  node.each { |n| traverse(n) }

end


##########################################
#
# fix_cyclestrs
#
##########################################
def fix_cyclestrs(node)

  return if node.entity?
  return if node.entity_ref?
  
  cyclestrs=node.find("./cyclestr")
  if !cyclestrs.empty?
    offsets=cyclestrs.collect { |c| c["offset"] }.compact
    if offsets.uniq.size < 2
      node.output_escaping = false
      content=node.children.collect {|c| c.to_s.strip}.join
      content.gsub!(/<\/?cyclestr(\s+offset="[^>]+"\s*)?>/,"")
      node.each { |n| n.remove! }
      newnode = LibXML::XML::Node.new("cyclestr",content)
      newnode["offset"]=offsets.first unless offsets.first.nil?
      node << newnode
      newnode.first.output_escaping=false
    end
  end

  node.each { |n| fix_cyclestrs(n) }

end


##########################################
#
# kill_joins
#
##########################################
def kill_joins(node)

joins=node.find('//property[name="-j"]')
joins.each {|n| n.remove! }

end


# Check for command line arguments
if ARGV.size != 1
  puts "USAGE:  translate workflow.xml"
  Process.exit(1)
end

# Parse the workflow xml string, set option to replace entities
xmlstring=IO.readlines(ARGV[0],nil)[0]
xmlstring=simple_substitutions(xmlstring)

workflowdoc=LibXML::XML::Document.string(xmlstring,:options => LibXML::XML::Parser::Options::NOBLANKS )

set_sched(workflowdoc.root)
set_cyclethrottle(workflowdoc.root)
traverse(workflowdoc.root)
fix_cyclestrs(workflowdoc.root)
kill_joins(workflowdoc.root)

puts workflowdoc
