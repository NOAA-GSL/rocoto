#!/usr/bin/ruby

# Get the base directory of the WFM installation
__WFMDIR__=File.expand_path("../../",__FILE__)

# Add include paths for WFM and libxml-ruby libraries
$:.unshift("#{__WFMDIR__}/lib")
$:.unshift("#{__WFMDIR__}/lib/libxml-ruby")
$:.unshift("#{__WFMDIR__}/lib/sqlite3-ruby")
$:.unshift("#{__WFMDIR__}/lib/SystemTimer")
$:.unshift("#{__WFMDIR__}/lib/open4/lib")

# Load workflow engine library
require 'tmpdir'
require 'drb'
require 'socket'
require 'workflowmgr/workflowserver'
require 'workflowmgr/utilities'
require 'libxml'
require 'fileutils'

# Set the verbosity for the server process
WorkflowMgr.const_set("VERBOSE",ARGV[1].to_i)

# Turn off that ridiculous Libxml-ruby handler that automatically sends output to stderr
# We want to control what output goes where and when                                     
LibXML::XML::Error.set_handler(&LibXML::XML::Error::QUIET_HANDLER)

# Set the name of the URI file based on the pid of this process
# This must happen before the server process is daemonized.
# Otherwise, the main thread has no way to know what pid to use.
uri_file="#{Dir.tmpdir}/rocoto_uri_#{$$}"

# Daemonize this process so that there aren't problems caused
# by failure to reap exit statuses and propagation of zombies
if RUBY_VERSION < "1.9"
  exit if fork
  Process.setsid
  exit if fork
  STDIN.reopen "/dev/null"
  STDOUT.reopen "/dev/null", "a" 
#  STDERR.reopen "/dev/null", "a"  # We need STDERR to report errors
else
  Process.daemon
end

# Start a Drb Server that will serve the workflow log object
DRb.start_service(nil,WorkflowMgr::WorkflowServer.new)

# Write the URI to a temp dir so the client can connect
begin
  File.open("#{uri_file}.tmp","w") { |file| file.puts "#{DRb.uri}" }
  FileUtils.mv("#{uri_file}.tmp",uri_file)
rescue
  # If we can't write the URI file, shut down the server because nothing is going to be able to talk to it
  WorkflowMgr.log($!)
  WorkflowMgr.stderr($!,1)
  DRb.stop_service
  Process.exit(1)
end

Thread.new do

  while true do

    begin

      # Test if the rocoto process that launched this server process has become a zombie
      system("ps -eo pid,stat | grep Z | grep #{ARGV[0].to_i} 2>&1 > /dev/null")

      # If our parent has become a zombie, it's time to close STDERR so that the zombie parent can go away
      if $?.exitstatus==0
        STDERR.reopen "/dev/null", "a"
        break
      end

    rescue
      WorkflowMgr.log($!)
      WorkflowMgr.stderr($!,1)
      STDERR.reopen "/dev/null", "a"
      break
    end

    sleep 5

  end

end

# Set up a safety thread to shutdown orphaned/abandoned server processes
Thread.new do

  hostinfo=Socket::getaddrinfo(Socket.gethostname, nil, nil, Socket::SOCK_STREAM)[0]

  # A safety net to shutdown the bqserver process if it has been alive for more than 4 days
  # The bqserver normally stays alive until all qsub status has been retrieved from it.
  # If the user runs Rocoto manually, and then goes home for the weekend, the status might
  # not get retrieved until the following week.  This is not ideal, but until a better 
  # solution is found, should catch those bqserver processes that get accidentally abandoned
  if $0=~/bqserver$/
    sleep 3600*24*4
    WorkflowMgr.log("Shutting down #{$0} server process #{Process.pid} on host #{hostinfo[2]} (#{hostinfo[3]}) because it appears to be abandoned")
    DRb.stop_service        

  # Shutdown the ioserver and dbserver processes as soon as they are orphaned (that should never happen unless rocotorun/rocotoboot dies uncleanly)   
  else
    while true do
      begin
        # Test if the rocoto process that launched this server process is still alive
        Process.getpgid(ARGV[0].to_i)
        sleep 1
      rescue Errno::ESRCH
        # If the process that launched this server is dead, shutdown this process
        WorkflowMgr.log("Shutting down #{$0} server process #{Process.pid} on host #{hostinfo[2]} (#{hostinfo[3]}) because it has been orphaned by an ungraceful shutdown.")
        DRb.stop_service        
      end
    end  # while true
  end  # unless $0

end  # Thread.new

# Wait forever for the server to quit
DRb.thread.join
